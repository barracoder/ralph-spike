@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using SpaceInvaders.Entities
@inject IJSRuntime JSRuntime
@inject GameStateService GameStateService
@implements IAsyncDisposable

<div class="game-container">
    <ScoreDisplay Score="_score" HighScore="_highScore" Lives="_lives" Wave="_wave" />
    @if (GameStateService.Current == GameState.Start)
    {
        <StartScreen />
    }
    @if (GameStateService.Current == GameState.GameOver)
    {
        <GameOverScreen />
    }
    <BECanvas Width="800" Height="600" @ref="_canvasRef"></BECanvas>
</div>

@code {
    private BECanvasComponent? _canvasRef;
    private Canvas2DContext? _context;
    private DotNetObjectReference<GameCanvas>? _dotNetRef;
    private bool _isRunning;
    private Player _player = new();
    private Bullet? _playerBullet;
    private bool _spaceWasPressed;
    private List<Invader> _invaders = new();
    private List<Bullet> _enemyBullets = new();
    private List<Shield> _shields = new();
    private Random _random = new();
    private int _invaderShootTimer = 0;
    private int _lives = 3;
    private int _score = 0;
    private int _highScore = 0;
    private const int InvaderShootInterval = 90; // Fire every ~1.5 seconds at 60fps
    private const float CanvasHeight = 600;

    private const int InvaderRows = 5;
    private const int InvaderColumns = 11;
    private const float InvaderSpacingX = 50;
    private const float InvaderSpacingY = 40;
    private const float InvaderStartX = 60;
    private const float InvaderStartY = 60;

    // Invader movement state
    private float _invaderDirection = 1; // 1 = right, -1 = left
    private float _invaderSpeed = 1.5f;
    private const float InvaderDropAmount = 20f;
    private const float CanvasWidth = 800;
    private const float CanvasPadding = 10;
    private int _wave = 1;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && _canvasRef != null)
        {
            _context = await _canvasRef.CreateCanvas2DAsync();
            await JSRuntime.InvokeVoidAsync("keyboard.init");
            InitializeInvaders();
            InitializeShields();
            await StartGameLoop();
        }
    }

    private void InitializeInvaders()
    {
        _invaders.Clear();
        for (int row = 0; row < InvaderRows; row++)
        {
            for (int col = 0; col < InvaderColumns; col++)
            {
                float x = InvaderStartX + (col * InvaderSpacingX);
                float y = InvaderStartY + (row * InvaderSpacingY);
                _invaders.Add(new Invader(row, col, x, y));
            }
        }
    }

    private void InitializeShields()
    {
        _shields.Clear();
        // Place 4 shields evenly spaced between player and invaders
        float shieldY = CanvasHeight - 150;
        int shieldCount = 4;
        float spacing = (CanvasWidth - 80 * shieldCount) / (shieldCount + 1);
        for (int i = 0; i < shieldCount; i++)
        {
            float x = spacing + i * (80 + spacing);
            _shields.Add(new Shield(x, shieldY, 80, 40, 3));
        }
    }

    private async Task StartGameLoop()
    {
        if (_isRunning) return;
        _isRunning = true;
        _dotNetRef = DotNetObjectReference.Create(this);
        await JSRuntime.InvokeVoidAsync("gameLoop.start", _dotNetRef);
    }

    [JSInvokable]
    public async Task GameLoopTick()
    {
        await Update();
        await Render();
        await InvokeAsync(StateHasChanged);
    }

    private async Task Update()
    {
        var keyState = await JSRuntime.InvokeAsync<KeyboardState>("keyboard.getState");

        // Handle game state transitions
        if (GameStateService.Current == GameState.Start)
        {
            if (keyState.Left || keyState.Right || keyState.Space)
            {
                GameStateService.StartGame();
            }
            return;
        }
        if (GameStateService.Current == GameState.GameOver)
        {
            return;
        }

        _player.Update(keyState.Left, keyState.Right);

        // Handle shooting (only fire on key down, not held)
        if (keyState.Space && !_spaceWasPressed && _playerBullet == null)
        {
            // Fire bullet from center top of player
            float bulletX = _player.X + (_player.Width / 2) - 2; // Center bullet (width 4)
            float bulletY = _player.Y - 10; // Above player
            _playerBullet = new Bullet(bulletX, bulletY);
        }
        _spaceWasPressed = keyState.Space;

        // Update player bullet
        if (_playerBullet != null)
        {
            _playerBullet.Update();
            if (_playerBullet.IsOffScreen())
            {
                _playerBullet = null;
            }
        }

        // Update invader movement
        UpdateInvaders();

        // Update enemy bullets
        UpdateEnemyBullets();

        // Collision detection: player bullet vs shields and invaders
        if (_playerBullet != null)
        {
            // Check shields first (shields absorb bullets)
            foreach (var shield in _shields.Where(s => s.IsAlive).ToList())
            {
                if (RectsIntersect(_playerBullet.X, _playerBullet.Y, _playerBullet.Width, _playerBullet.Height,
                                   shield.X, shield.Y, shield.Width, shield.Height))
                {
                    shield.TakeDamage(1);
                    _playerBullet = null;
                    break;
                }
            }

            // If bullet still exists, check invaders
            if (_playerBullet != null)
            {
                foreach (var invader in _invaders.Where(i => i.IsAlive).ToList())
                {
                    if (RectsIntersect(_playerBullet.X, _playerBullet.Y, _playerBullet.Width, _playerBullet.Height,
                                       invader.X, invader.Y, invader.Width, invader.Height))
                    {
                        invader.IsAlive = false;
                        _playerBullet = null;
                        _score += 100;
                        if (_score > _highScore) _highScore = _score;
                        break;
                    }
                }
            }
        }

        // Collision detection: enemy bullets vs shields and player
        for (int i = _enemyBullets.Count - 1; i >= 0; i--)
        {
            var b = _enemyBullets[i];

            // Check shields first
            bool absorbed = false;
            foreach (var shield in _shields.Where(s => s.IsAlive).ToList())
            {
                if (RectsIntersect(b.X, b.Y, b.Width, b.Height, shield.X, shield.Y, shield.Width, shield.Height))
                {
                    shield.TakeDamage(1);
                    _enemyBullets.RemoveAt(i);
                    absorbed = true;
                    break;
                }
            }
            if (absorbed) continue;

            if (RectsIntersect(b.X, b.Y, b.Width, b.Height, _player.X, _player.Y, _player.Width, _player.Height))
            {
                _enemyBullets.RemoveAt(i);
                _lives--;
                if (_lives <= 0)
                {
                    GameStateService.SetGameOver();
                }
            }
        }
    }

    private void UpdateEnemyBullets()
    {
        // Fire periodically from random bottom-row invader
        _invaderShootTimer++;
        if (_invaderShootTimer >= InvaderShootInterval)
        {
            _invaderShootTimer = 0;
            FireFromRandomBottomInvader();
        }

        // Update existing enemy bullets
        foreach (var bullet in _enemyBullets)
        {
            bullet.Update();
        }

        // Remove off-screen bullets
        _enemyBullets.RemoveAll(b => b.IsOffScreen());
    }

    private void FireFromRandomBottomInvader()
    {
        var aliveInvaders = _invaders.Where(i => i.IsAlive).ToList();
        if (aliveInvaders.Count == 0) return;

        // Find bottom-row invaders for each column (highest Y value per column)
        var bottomInvaders = aliveInvaders
            .GroupBy(i => i.Column)
            .Select(g => g.OrderByDescending(i => i.Y).First())
            .ToList();

        if (bottomInvaders.Count == 0) return;

        // Select random bottom-row invader
        var shooter = bottomInvaders[_random.Next(bottomInvaders.Count)];
        
        // Fire bullet from center bottom of invader
        float bulletX = shooter.X + (shooter.Width / 2) - 2;
        float bulletY = shooter.Y + shooter.Height;
        _enemyBullets.Add(new Bullet(bulletX, bulletY, 5)); // Positive speed = downward
    }

    private void UpdateInvaders()
    {
        var aliveInvaders = _invaders.Where(i => i.IsAlive).ToList();
        if (aliveInvaders.Count == 0)
        {
            StartNextWave();
            return;
        }

        // Check if any invader would hit edge after this move
        bool shouldReverse = false;
        foreach (var invader in aliveInvaders)
        {
            float nextX = invader.X + (_invaderDirection * _invaderSpeed);
            if (nextX <= CanvasPadding || nextX + invader.Width >= CanvasWidth - CanvasPadding)
            {
                shouldReverse = true;
                break;
            }
        }

        if (shouldReverse)
        {
            // Drop down and reverse direction
            foreach (var invader in aliveInvaders)
            {
                invader.Move(0, InvaderDropAmount);
            }
            _invaderDirection *= -1;
        }
        else
        {
            // Move horizontally
            foreach (var invader in aliveInvaders)
            {
                invader.Move(_invaderDirection * _invaderSpeed, 0);
            }
        }
    }

    private void StartNextWave()
    {
        _wave++;
        _invaderSpeed *= 1.2f;
        InitializeInvaders();
        _invaderDirection = 1;
        _enemyBullets.Clear();
    }

    private bool RectsIntersect(float x1, float y1, float w1, float h1, float x2, float y2, float w2, float h2)
    {
        return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
    }

    private async Task Render()
    {
        if (_context == null) return;
        
        // Clear canvas with black background each frame
        await _context.SetFillStyleAsync("#000000");
        await _context.FillRectAsync(0, 0, 800, 600);

        // Draw player as green rectangle
        await _context.SetFillStyleAsync("#00FF00");
        await _context.FillRectAsync(_player.X, _player.Y, _player.Width, _player.Height);

        // Draw player bullet (white)
        if (_playerBullet != null)
        {
            await _context.SetFillStyleAsync("#FFFFFF");
            await _context.FillRectAsync(_playerBullet.X, _playerBullet.Y, _playerBullet.Width, _playerBullet.Height);
        }

        // Draw shields
        foreach (var shield in _shields)
        {
            if (shield.IsAlive)
            {
                var alpha = shield.HealthFraction();
                var fill = $"rgba(0,170,0,{alpha})";
                await _context.SetFillStyleAsync(fill);
                await _context.FillRectAsync(shield.X, shield.Y, shield.Width, shield.Height);
            }
        }

        // Draw invaders (white rectangles)
        await _context.SetFillStyleAsync("#FFFFFF");
        foreach (var invader in _invaders)
        {
            if (invader.IsAlive)
            {
                await _context.FillRectAsync(invader.X, invader.Y, invader.Width, invader.Height);
            }
        }

        // Draw enemy bullets (red)
        await _context.SetFillStyleAsync("#FF0000");
        foreach (var bullet in _enemyBullets)
        {
            await _context.FillRectAsync(bullet.X, bullet.Y, bullet.Width, bullet.Height);
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_isRunning)
        {
            await JSRuntime.InvokeVoidAsync("gameLoop.stop");
            _isRunning = false;
        }
        _dotNetRef?.Dispose();
    }

    private class KeyboardState
    {
        public bool Left { get; set; }
        public bool Right { get; set; }
        public bool Space { get; set; }
    }
}
