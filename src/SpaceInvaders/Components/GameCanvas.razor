@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using SpaceInvaders.Entities
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div class="game-container">
    <BECanvas Width="800" Height="600" @ref="_canvasRef"></BECanvas>
</div>

@code {
    private BECanvasComponent? _canvasRef;
    private Canvas2DContext? _context;
    private DotNetObjectReference<GameCanvas>? _dotNetRef;
    private bool _isRunning;
    private Player _player = new();
    private Bullet? _playerBullet;
    private bool _spaceWasPressed;
    private List<Invader> _invaders = new();

    private const int InvaderRows = 5;
    private const int InvaderColumns = 11;
    private const float InvaderSpacingX = 50;
    private const float InvaderSpacingY = 40;
    private const float InvaderStartX = 60;
    private const float InvaderStartY = 60;

    // Invader movement state
    private float _invaderDirection = 1; // 1 = right, -1 = left
    private const float InvaderSpeed = 1.5f;
    private const float InvaderDropAmount = 20f;
    private const float CanvasWidth = 800;
    private const float CanvasPadding = 10;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && _canvasRef != null)
        {
            _context = await _canvasRef.CreateCanvas2DAsync();
            await JSRuntime.InvokeVoidAsync("keyboard.init");
            InitializeInvaders();
            await StartGameLoop();
        }
    }

    private void InitializeInvaders()
    {
        _invaders.Clear();
        for (int row = 0; row < InvaderRows; row++)
        {
            for (int col = 0; col < InvaderColumns; col++)
            {
                float x = InvaderStartX + (col * InvaderSpacingX);
                float y = InvaderStartY + (row * InvaderSpacingY);
                _invaders.Add(new Invader(row, col, x, y));
            }
        }
    }

    private async Task StartGameLoop()
    {
        if (_isRunning) return;
        _isRunning = true;
        _dotNetRef = DotNetObjectReference.Create(this);
        await JSRuntime.InvokeVoidAsync("gameLoop.start", _dotNetRef);
    }

    [JSInvokable]
    public async Task GameLoopTick()
    {
        await Update();
        await Render();
    }

    private async Task Update()
    {
        var keyState = await JSRuntime.InvokeAsync<KeyboardState>("keyboard.getState");
        _player.Update(keyState.Left, keyState.Right);

        // Handle shooting (only fire on key down, not held)
        if (keyState.Space && !_spaceWasPressed && _playerBullet == null)
        {
            // Fire bullet from center top of player
            float bulletX = _player.X + (_player.Width / 2) - 2; // Center bullet (width 4)
            float bulletY = _player.Y - 10; // Above player
            _playerBullet = new Bullet(bulletX, bulletY);
        }
        _spaceWasPressed = keyState.Space;

        // Update player bullet
        if (_playerBullet != null)
        {
            _playerBullet.Update();
            if (_playerBullet.IsOffScreen())
            {
                _playerBullet = null;
            }
        }

        // Update invader movement
        UpdateInvaders();
    }

    private void UpdateInvaders()
    {
        var aliveInvaders = _invaders.Where(i => i.IsAlive).ToList();
        if (aliveInvaders.Count == 0) return;

        // Check if any invader would hit edge after this move
        bool shouldReverse = false;
        foreach (var invader in aliveInvaders)
        {
            float nextX = invader.X + (_invaderDirection * InvaderSpeed);
            if (nextX <= CanvasPadding || nextX + invader.Width >= CanvasWidth - CanvasPadding)
            {
                shouldReverse = true;
                break;
            }
        }

        if (shouldReverse)
        {
            // Drop down and reverse direction
            foreach (var invader in aliveInvaders)
            {
                invader.Move(0, InvaderDropAmount);
            }
            _invaderDirection *= -1;
        }
        else
        {
            // Move horizontally
            foreach (var invader in aliveInvaders)
            {
                invader.Move(_invaderDirection * InvaderSpeed, 0);
            }
        }
    }

    private async Task Render()
    {
        if (_context == null) return;
        
        // Clear canvas with black background each frame
        await _context.SetFillStyleAsync("#000000");
        await _context.FillRectAsync(0, 0, 800, 600);

        // Draw player as green rectangle
        await _context.SetFillStyleAsync("#00FF00");
        await _context.FillRectAsync(_player.X, _player.Y, _player.Width, _player.Height);

        // Draw player bullet (white)
        if (_playerBullet != null)
        {
            await _context.SetFillStyleAsync("#FFFFFF");
            await _context.FillRectAsync(_playerBullet.X, _playerBullet.Y, _playerBullet.Width, _playerBullet.Height);
        }

        // Draw invaders (white rectangles)
        await _context.SetFillStyleAsync("#FFFFFF");
        foreach (var invader in _invaders)
        {
            if (invader.IsAlive)
            {
                await _context.FillRectAsync(invader.X, invader.Y, invader.Width, invader.Height);
            }
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_isRunning)
        {
            await JSRuntime.InvokeVoidAsync("gameLoop.stop");
            _isRunning = false;
        }
        _dotNetRef?.Dispose();
    }

    private class KeyboardState
    {
        public bool Left { get; set; }
        public bool Right { get; set; }
        public bool Space { get; set; }
    }
}
