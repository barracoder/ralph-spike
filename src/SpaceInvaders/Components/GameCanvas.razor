@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using SpaceInvaders.Entities
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div class="game-container">
    <BECanvas Width="800" Height="600" @ref="_canvasRef"></BECanvas>
</div>

@code {
    private BECanvasComponent? _canvasRef;
    private Canvas2DContext? _context;
    private DotNetObjectReference<GameCanvas>? _dotNetRef;
    private bool _isRunning;
    private Player _player = new();
    private Bullet? _playerBullet;
    private bool _spaceWasPressed;
    private List<Invader> _invaders = new();
    private List<Bullet> _enemyBullets = new();
    private Random _random = new();
    private int _invaderShootTimer = 0;
    private int _lives = 3;
    private const int InvaderShootInterval = 90; // Fire every ~1.5 seconds at 60fps

    private const int InvaderRows = 5;
    private const int InvaderColumns = 11;
    private const float InvaderSpacingX = 50;
    private const float InvaderSpacingY = 40;
    private const float InvaderStartX = 60;
    private const float InvaderStartY = 60;

    // Invader movement state
    private float _invaderDirection = 1; // 1 = right, -1 = left
    private const float InvaderSpeed = 1.5f;
    private const float InvaderDropAmount = 20f;
    private const float CanvasWidth = 800;
    private const float CanvasPadding = 10;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && _canvasRef != null)
        {
            _context = await _canvasRef.CreateCanvas2DAsync();
            await JSRuntime.InvokeVoidAsync("keyboard.init");
            InitializeInvaders();
            await StartGameLoop();
        }
    }

    private void InitializeInvaders()
    {
        _invaders.Clear();
        for (int row = 0; row < InvaderRows; row++)
        {
            for (int col = 0; col < InvaderColumns; col++)
            {
                float x = InvaderStartX + (col * InvaderSpacingX);
                float y = InvaderStartY + (row * InvaderSpacingY);
                _invaders.Add(new Invader(row, col, x, y));
            }
        }
    }

    private async Task StartGameLoop()
    {
        if (_isRunning) return;
        _isRunning = true;
        _dotNetRef = DotNetObjectReference.Create(this);
        await JSRuntime.InvokeVoidAsync("gameLoop.start", _dotNetRef);
    }

    [JSInvokable]
    public async Task GameLoopTick()
    {
        await Update();
        await Render();
    }

    private async Task Update()
    {
        var keyState = await JSRuntime.InvokeAsync<KeyboardState>("keyboard.getState");
        _player.Update(keyState.Left, keyState.Right);

        // Handle shooting (only fire on key down, not held)
        if (keyState.Space && !_spaceWasPressed && _playerBullet == null)
        {
            // Fire bullet from center top of player
            float bulletX = _player.X + (_player.Width / 2) - 2; // Center bullet (width 4)
            float bulletY = _player.Y - 10; // Above player
            _playerBullet = new Bullet(bulletX, bulletY);
        }
        _spaceWasPressed = keyState.Space;

        // Update player bullet
        if (_playerBullet != null)
        {
            _playerBullet.Update();
            if (_playerBullet.IsOffScreen())
            {
                _playerBullet = null;
            }
        }

        // Update invader movement
        UpdateInvaders();

        // Update enemy bullets
        UpdateEnemyBullets();

        // Collision detection: player bullet vs invaders
        if (_playerBullet != null)
        {
            foreach (var invader in _invaders.Where(i => i.IsAlive).ToList())
            {
                if (RectsIntersect(_playerBullet.X, _playerBullet.Y, _playerBullet.Width, _playerBullet.Height,
                                   invader.X, invader.Y, invader.Width, invader.Height))
                {
                    invader.IsAlive = false;
                    _playerBullet = null;
                    break;
                }
            }
        }

        // Collision detection: enemy bullets vs player
        for (int i = _enemyBullets.Count - 1; i >= 0; i--)
        {
            var b = _enemyBullets[i];
            if (RectsIntersect(b.X, b.Y, b.Width, b.Height, _player.X, _player.Y, _player.Width, _player.Height))
            {
                _enemyBullets.RemoveAt(i);
                _lives--;
                // TODO: handle game over when _lives <= 0
            }
        }
    }

    private void UpdateEnemyBullets()
    {
        // Fire periodically from random bottom-row invader
        _invaderShootTimer++;
        if (_invaderShootTimer >= InvaderShootInterval)
        {
            _invaderShootTimer = 0;
            FireFromRandomBottomInvader();
        }

        // Update existing enemy bullets
        foreach (var bullet in _enemyBullets)
        {
            bullet.Update();
        }

        // Remove off-screen bullets
        _enemyBullets.RemoveAll(b => b.IsOffScreen());
    }

    private void FireFromRandomBottomInvader()
    {
        var aliveInvaders = _invaders.Where(i => i.IsAlive).ToList();
        if (aliveInvaders.Count == 0) return;

        // Find bottom-row invaders for each column (highest Y value per column)
        var bottomInvaders = aliveInvaders
            .GroupBy(i => i.Column)
            .Select(g => g.OrderByDescending(i => i.Y).First())
            .ToList();

        if (bottomInvaders.Count == 0) return;

        // Select random bottom-row invader
        var shooter = bottomInvaders[_random.Next(bottomInvaders.Count)];
        
        // Fire bullet from center bottom of invader
        float bulletX = shooter.X + (shooter.Width / 2) - 2;
        float bulletY = shooter.Y + shooter.Height;
        _enemyBullets.Add(new Bullet(bulletX, bulletY, 5)); // Positive speed = downward
    }

    private void UpdateInvaders()
    {
        var aliveInvaders = _invaders.Where(i => i.IsAlive).ToList();
        if (aliveInvaders.Count == 0) return;

        // Check if any invader would hit edge after this move
        bool shouldReverse = false;
        foreach (var invader in aliveInvaders)
        {
            float nextX = invader.X + (_invaderDirection * InvaderSpeed);
            if (nextX <= CanvasPadding || nextX + invader.Width >= CanvasWidth - CanvasPadding)
            {
                shouldReverse = true;
                break;
            }
        }

        if (shouldReverse)
        {
            // Drop down and reverse direction
            foreach (var invader in aliveInvaders)
            {
                invader.Move(0, InvaderDropAmount);
            }
            _invaderDirection *= -1;
        }
        else
        {
            // Move horizontally
            foreach (var invader in aliveInvaders)
            {
                invader.Move(_invaderDirection * InvaderSpeed, 0);
            }
        }
    }

    private bool RectsIntersect(float x1, float y1, float w1, float h1, float x2, float y2, float w2, float h2)
    {
        return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
    }

    private async Task Render()
    {
        if (_context == null) return;
        
        // Clear canvas with black background each frame
        await _context.SetFillStyleAsync("#000000");
        await _context.FillRectAsync(0, 0, 800, 600);

        // Draw player as green rectangle
        await _context.SetFillStyleAsync("#00FF00");
        await _context.FillRectAsync(_player.X, _player.Y, _player.Width, _player.Height);

        // Draw player bullet (white)
        if (_playerBullet != null)
        {
            await _context.SetFillStyleAsync("#FFFFFF");
            await _context.FillRectAsync(_playerBullet.X, _playerBullet.Y, _playerBullet.Width, _playerBullet.Height);
        }

        // Draw invaders (white rectangles)
        await _context.SetFillStyleAsync("#FFFFFF");
        foreach (var invader in _invaders)
        {
            if (invader.IsAlive)
            {
                await _context.FillRectAsync(invader.X, invader.Y, invader.Width, invader.Height);
            }
        }

        // Draw enemy bullets (red)
        await _context.SetFillStyleAsync("#FF0000");
        foreach (var bullet in _enemyBullets)
        {
            await _context.FillRectAsync(bullet.X, bullet.Y, bullet.Width, bullet.Height);
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_isRunning)
        {
            await JSRuntime.InvokeVoidAsync("gameLoop.stop");
            _isRunning = false;
        }
        _dotNetRef?.Dispose();
    }

    private class KeyboardState
    {
        public bool Left { get; set; }
        public bool Right { get; set; }
        public bool Space { get; set; }
    }
}
